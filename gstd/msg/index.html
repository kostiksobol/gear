<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Messaging API for Gear programs."><title>gstd::msg - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceSerif4-Bold-a2c9cd1067f8b328.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../static.files/rustdoc-ba5701c5741a7b69.css" id="mainThemeStyle"><div id="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="gstd" data-themes="" data-resource-suffix="" data-rustdoc-version="1.71.0-nightly (f5559e338 2023-04-24)" data-search-js="search-618e954b235f6acc.js" data-settings-js="settings-de11bff964e9d4e5.js" data-settings-css="settings-6f6ffb5395b17c6e.css" data-theme-light-css="light-0f8c037637f9eb3e.css" data-theme-dark-css="dark-1097f8e92a01e3cf.css" data-theme-ayu-css="ayu-614652228113ac93.css" ></div><script src="../../static.files/storage-62ce34ea385b278a.js"></script><script defer src="../../static.files/main-f0540c1d82cde29b.js"></script><noscript><link rel="stylesheet" media="(prefers-color-scheme:light)" href="../../static.files/light-0f8c037637f9eb3e.css"><link rel="stylesheet" media="(prefers-color-scheme:dark)" href="../../static.files/dark-1097f8e92a01e3cf.css"><link rel="stylesheet" href="../../static.files/noscript-13285aec31fa243e.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="logo-container" href="../../gstd/index.html"><img src="https://docs.gear.rs/logo.svg" alt="logo"></a><h2></h2></nav><nav class="sidebar"><a class="logo-container" href="../../gstd/index.html"><img src="https://docs.gear.rs/logo.svg" alt="logo"></a><h2 class="location"><a href="#">Module msg</a></h2><div class="sidebar-elems"><section><ul class="block"><li><a href="#structs">Structs</a></li><li><a href="#functions">Functions</a></li></ul></section></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Module <a href="../index.html">gstd</a>::<wbr><a class="mod" href="#">msg</a><button id="copy-path" title="Copy item path to clipboard"><img src="../../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="srclink" href="../../src/gstd/msg/mod.rs.html#19-55">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Messaging API for Gear programs.</p>
<p>This module contains an API to process incoming messages and send outgoing
ones. Messages are the primary communication interface between actors (users
and programs).</p>
<p>Every Gear program has code that handles messages. During message
processing, a program can send messages to other programs and users,
including a reply to the initial message.</p>
<p>When some actor (user or program) sends a message to the program, it invokes
this program by executing the <code>handle</code> function. The invoked program can
obtain details of incoming messages by using this module’s API (<a href="fn.source.html" title="fn gstd::msg::source"><code>source</code></a>,
<a href="fn.size.html" title="fn gstd::msg::size"><code>size</code></a>, <a href="fn.load.html" title="fn gstd::msg::load"><code>load</code></a>, <a href="fn.id.html" title="fn gstd::msg::id"><code>id</code></a>, <a href="fn.value.html" title="fn gstd::msg::value"><code>value</code></a>, etc.).</p>
<p>Optionally the program can send one or more messages to other actors. Also,
it can send a reply that differs from a regular message in two ways:</p>
<ul>
<li>There can be no more than one reply;</li>
<li>It is impossible to choose the reply’s destination, as it is always sent
to the program invoker.</li>
</ul>
<p>Note that messages and a reply are not sent immediately but collected during
the program execution and enqueued after the execution successfully ends.</p>
</div></details><h2 id="structs" class="small-section-header"><a href="#structs">Structs</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.CodecCreateProgramFuture.html" title="struct gstd::msg::CodecCreateProgramFuture">CodecCreateProgramFuture</a></div><div class="desc docblock-short">Same as <a href="struct.CreateProgramFuture.html" title="struct gstd::msg::CreateProgramFuture"><code>CreateProgramFuture</code></a>, but allows decoding the reply’s payload
instead of receiving a byte vector.</div></li><li><div class="item-name"><a class="struct" href="struct.CodecMessageFuture.html" title="struct gstd::msg::CodecMessageFuture">CodecMessageFuture</a></div><div class="desc docblock-short">Same as <a href="struct.MessageFuture.html" title="struct gstd::msg::MessageFuture"><code>MessageFuture</code></a>, but allows decoding the reply’s payload instead
of getting a byte vector.</div></li><li><div class="item-name"><a class="struct" href="struct.CreateProgramFuture.html" title="struct gstd::msg::CreateProgramFuture">CreateProgramFuture</a></div><div class="desc docblock-short">Async functions that relate to creating programs wait for a reply from the
program’s init function. These functions have the suffix<code> _for_reply</code>, such
as <a href="../prog/fn.create_program_for_reply.html" title="fn gstd::prog::create_program_for_reply"><code>crate::prog::create_program_for_reply</code></a>.</div></li><li><div class="item-name"><a class="struct" href="struct.MessageFuture.html" title="struct gstd::msg::MessageFuture">MessageFuture</a></div><div class="desc docblock-short">Future returned by async functions related to message sending that wait for
a reply (see sending functions with <code>_for_reply</code> suffix, e.g.
<a href="fn.send_bytes_for_reply.html" title="fn gstd::msg::send_bytes_for_reply"><code>send_bytes_for_reply</code></a>).</div></li><li><div class="item-name"><a class="struct" href="struct.MessageHandle.html" title="struct gstd::msg::MessageHandle">MessageHandle</a></div><div class="desc docblock-short">Message handle.</div></li></ul><h2 id="functions" class="small-section-header"><a href="#functions">Functions</a></h2><ul class="item-table"><li><div class="item-name"><a class="fn" href="fn.id.html" title="fn gstd::msg::id">id</a></div><div class="desc docblock-short">Get an identifier of the message that is currently being processed.</div></li><li><div class="item-name"><a class="fn" href="fn.load.html" title="fn gstd::msg::load">load</a></div><div class="desc docblock-short">Get a payload of the message that is currently being processed.</div></li><li><div class="item-name"><a class="fn" href="fn.load_bytes.html" title="fn gstd::msg::load_bytes">load_bytes</a></div><div class="desc docblock-short">Get a payload of the message that is currently being processed.</div></li><li><div class="item-name"><a class="fn" href="fn.load_on_stack.html" title="fn gstd::msg::load_on_stack">load_on_stack</a></div><div class="desc docblock-short">Same as <a href="fn.load.html" title="fn gstd::msg::load"><code>load</code></a>, but reads current message payload to allocated
on stack buffer. Decoded object will be also on stack, but if it contains
any fields, with heap allocations inside (for example vec), then
this decoding may lead to heap allocations.</div></li><li><div class="item-name"><a class="fn" href="fn.reply.html" title="fn gstd::msg::reply">reply</a></div><div class="desc docblock-short">Send a new message as a reply to the message being
processed.</div></li><li><div class="item-name"><a class="fn" href="fn.reply_bytes.html" title="fn gstd::msg::reply_bytes">reply_bytes</a></div><div class="desc docblock-short">Send a new message as a reply to the message that is currently being
processed.</div></li><li><div class="item-name"><a class="fn" href="fn.reply_bytes_from_reservation.html" title="fn gstd::msg::reply_bytes_from_reservation">reply_bytes_from_reservation</a></div><div class="desc docblock-short">Same as <a href="fn.reply_bytes.html" title="fn gstd::msg::reply_bytes"><code>reply_bytes</code></a>, but it spends gas from a reservation instead of
borrowing it from the gas limit provided with the incoming message.</div></li><li><div class="item-name"><a class="fn" href="fn.reply_bytes_with_gas.html" title="fn gstd::msg::reply_bytes_with_gas">reply_bytes_with_gas</a></div><div class="desc docblock-short">Same as <a href="fn.reply_bytes.html" title="fn gstd::msg::reply_bytes"><code>reply_bytes</code></a>, but with an explicit gas limit.</div></li><li><div class="item-name"><a class="fn" href="fn.reply_code.html" title="fn gstd::msg::reply_code">reply_code</a></div><div class="desc docblock-short">Get the reply code of the message being processed.</div></li><li><div class="item-name"><a class="fn" href="fn.reply_commit.html" title="fn gstd::msg::reply_commit">reply_commit</a></div><div class="desc docblock-short">Finalize and send the current reply message.</div></li><li><div class="item-name"><a class="fn" href="fn.reply_commit_from_reservation.html" title="fn gstd::msg::reply_commit_from_reservation">reply_commit_from_reservation</a></div><div class="desc docblock-short">Same as <a href="fn.reply_commit.html" title="fn gstd::msg::reply_commit"><code>reply_commit</code></a>, but it spends gas from a reservation instead of
borrowing it from the gas limit provided with the incoming message.</div></li><li><div class="item-name"><a class="fn" href="fn.reply_commit_with_gas.html" title="fn gstd::msg::reply_commit_with_gas">reply_commit_with_gas</a></div><div class="desc docblock-short">Same as <a href="fn.reply_commit.html" title="fn gstd::msg::reply_commit"><code>reply_commit</code></a>, but with an explicit gas limit.</div></li><li><div class="item-name"><a class="fn" href="fn.reply_from_reservation.html" title="fn gstd::msg::reply_from_reservation">reply_from_reservation</a></div><div class="desc docblock-short">Same as <a href="fn.reply.html" title="fn gstd::msg::reply"><code>reply</code></a>, but it spends gas from a reservation instead of
borrowing gas from the gas limit provided with the incoming message.</div></li><li><div class="item-name"><a class="fn" href="fn.reply_input.html" title="fn gstd::msg::reply_input">reply_input</a></div><div class="desc docblock-short">Same as <a href="fn.reply.html" title="fn gstd::msg::reply"><code>reply</code></a> but uses the input buffer as a payload source.</div></li><li><div class="item-name"><a class="fn" href="fn.reply_input_with_gas.html" title="fn gstd::msg::reply_input_with_gas">reply_input_with_gas</a></div><div class="desc docblock-short">Same as <a href="fn.reply_input.html" title="fn gstd::msg::reply_input"><code>reply_input</code></a>, but with an explicit gas limit.</div></li><li><div class="item-name"><a class="fn" href="fn.reply_on_stack.html" title="fn gstd::msg::reply_on_stack">reply_on_stack</a></div><div class="desc docblock-short">Same as <a href="fn.reply.html" title="fn gstd::msg::reply">reply</a>, but encodes payload to stack allocated buffer.
Buffer size for encoding is at least <code>E::max_encoded_len()</code>.</div></li><li><div class="item-name"><a class="fn" href="fn.reply_push.html" title="fn gstd::msg::reply_push">reply_push</a></div><div class="desc docblock-short">Push a payload part to the current reply message.</div></li><li><div class="item-name"><a class="fn" href="fn.reply_push_input.html" title="fn gstd::msg::reply_push_input">reply_push_input</a></div><div class="desc docblock-short">Same as <a href="fn.reply_push.html" title="fn gstd::msg::reply_push"><code>reply_push</code></a> but uses the input buffer as a payload source.</div></li><li><div class="item-name"><a class="fn" href="fn.reply_to.html" title="fn gstd::msg::reply_to">reply_to</a></div><div class="desc docblock-short">Get an identifier of the initial message on which the current <code>handle_reply</code>
function is called.</div></li><li><div class="item-name"><a class="fn" href="fn.reply_with_gas.html" title="fn gstd::msg::reply_with_gas">reply_with_gas</a></div><div class="desc docblock-short">Same as <a href="fn.reply.html" title="fn gstd::msg::reply"><code>reply</code></a>, but with an explicit gas limit.</div></li><li><div class="item-name"><a class="fn" href="fn.send.html" title="fn gstd::msg::send">send</a></div><div class="desc docblock-short">Send a new message to the program or user.</div></li><li><div class="item-name"><a class="fn" href="fn.send_bytes.html" title="fn gstd::msg::send_bytes">send_bytes</a></div><div class="desc docblock-short">Send a new message to the program or user.</div></li><li><div class="item-name"><a class="fn" href="fn.send_bytes_delayed.html" title="fn gstd::msg::send_bytes_delayed">send_bytes_delayed</a></div><div class="desc docblock-short">Same as <a href="fn.send_bytes.html" title="fn gstd::msg::send_bytes"><code>send_bytes</code></a>, but sends the message after the <code>delay</code> expressed in
block count.</div></li><li><div class="item-name"><a class="fn" href="fn.send_bytes_delayed_from_reservation.html" title="fn gstd::msg::send_bytes_delayed_from_reservation">send_bytes_delayed_from_reservation</a></div><div class="desc docblock-short">Same as <a href="fn.send_bytes_from_reservation.html" title="fn gstd::msg::send_bytes_from_reservation"><code>send_bytes_from_reservation</code></a>, but sends the message after the
<code>delay</code> expressed in block count.</div></li><li><div class="item-name"><a class="fn" href="fn.send_bytes_for_reply.html" title="fn gstd::msg::send_bytes_for_reply">send_bytes_for_reply</a></div><div class="desc docblock-short">Same as <a href="fn.send_bytes.html" title="fn gstd::msg::send_bytes"><code>send_bytes</code></a>, but the program
will interrupt until the reply is received.</div></li><li><div class="item-name"><a class="fn" href="fn.send_bytes_for_reply_as.html" title="fn gstd::msg::send_bytes_for_reply_as">send_bytes_for_reply_as</a></div><div class="desc docblock-short">Same as <a href="fn.send_bytes.html" title="fn gstd::msg::send_bytes"><code>send_bytes</code></a>, but the program
will interrupt until the reply is received.</div></li><li><div class="item-name"><a class="fn" href="fn.send_bytes_from_reservation.html" title="fn gstd::msg::send_bytes_from_reservation">send_bytes_from_reservation</a></div><div class="desc docblock-short">Same as <a href="fn.send_bytes.html" title="fn gstd::msg::send_bytes"><code>send_bytes</code></a>, but it spends gas from a reservation instead of
borrowing it from the gas limit provided with the incoming message.</div></li><li><div class="item-name"><a class="fn" href="fn.send_bytes_from_reservation_for_reply.html" title="fn gstd::msg::send_bytes_from_reservation_for_reply">send_bytes_from_reservation_for_reply</a></div><div class="desc docblock-short">Same as <a href="fn.send_bytes_from_reservation.html" title="fn gstd::msg::send_bytes_from_reservation"><code>send_bytes_from_reservation</code></a>, but the program
will interrupt until the reply is received.</div></li><li><div class="item-name"><a class="fn" href="fn.send_bytes_from_reservation_for_reply_as.html" title="fn gstd::msg::send_bytes_from_reservation_for_reply_as">send_bytes_from_reservation_for_reply_as</a></div><div class="desc docblock-short">Same as <a href="fn.send_bytes_from_reservation.html" title="fn gstd::msg::send_bytes_from_reservation"><code>send_bytes_from_reservation</code></a>, but the program
will interrupt until the reply is received.</div></li><li><div class="item-name"><a class="fn" href="fn.send_bytes_with_gas.html" title="fn gstd::msg::send_bytes_with_gas">send_bytes_with_gas</a></div><div class="desc docblock-short">Same as <a href="fn.send_bytes.html" title="fn gstd::msg::send_bytes"><code>send_bytes</code></a>, but with an explicit gas limit.</div></li><li><div class="item-name"><a class="fn" href="fn.send_bytes_with_gas_delayed.html" title="fn gstd::msg::send_bytes_with_gas_delayed">send_bytes_with_gas_delayed</a></div><div class="desc docblock-short">Same as <a href="fn.send_bytes_with_gas.html" title="fn gstd::msg::send_bytes_with_gas"><code>send_bytes_with_gas</code></a>, but sends the message after the <code>delay</code>
expressed in block count.</div></li><li><div class="item-name"><a class="fn" href="fn.send_bytes_with_gas_for_reply.html" title="fn gstd::msg::send_bytes_with_gas_for_reply">send_bytes_with_gas_for_reply</a></div><div class="desc docblock-short">Same as <a href="fn.send_bytes_with_gas.html" title="fn gstd::msg::send_bytes_with_gas"><code>send_bytes_with_gas</code></a>, but the program
will interrupt until the reply is received.</div></li><li><div class="item-name"><a class="fn" href="fn.send_bytes_with_gas_for_reply_as.html" title="fn gstd::msg::send_bytes_with_gas_for_reply_as">send_bytes_with_gas_for_reply_as</a></div><div class="desc docblock-short">Same as <a href="fn.send_bytes_with_gas.html" title="fn gstd::msg::send_bytes_with_gas"><code>send_bytes_with_gas</code></a>, but the program
will interrupt until the reply is received.</div></li><li><div class="item-name"><a class="fn" href="fn.send_delayed.html" title="fn gstd::msg::send_delayed">send_delayed</a></div><div class="desc docblock-short">Same as <a href="fn.send.html" title="fn gstd::msg::send"><code>send</code></a>, but sends the message after the <code>delay</code> expressed in block
count.</div></li><li><div class="item-name"><a class="fn" href="fn.send_delayed_from_reservation.html" title="fn gstd::msg::send_delayed_from_reservation">send_delayed_from_reservation</a></div><div class="desc docblock-short">Same as <a href="fn.send_from_reservation.html" title="fn gstd::msg::send_from_reservation"><code>send_from_reservation</code></a>, but sends the message after the <code>delay</code>
expressed in block count.</div></li><li><div class="item-name"><a class="fn" href="fn.send_for_reply.html" title="fn gstd::msg::send_for_reply">send_for_reply</a></div><div class="desc docblock-short">Same as <a href="fn.send.html" title="fn gstd::msg::send"><code>send</code></a>, but the program
will interrupt until the reply is received.</div></li><li><div class="item-name"><a class="fn" href="fn.send_for_reply_as.html" title="fn gstd::msg::send_for_reply_as">send_for_reply_as</a></div><div class="desc docblock-short">Same as <a href="fn.send.html" title="fn gstd::msg::send"><code>send</code></a>, but the program
will interrupt until the reply is received.</div></li><li><div class="item-name"><a class="fn" href="fn.send_from_reservation.html" title="fn gstd::msg::send_from_reservation">send_from_reservation</a></div><div class="desc docblock-short">Same as <a href="fn.send.html" title="fn gstd::msg::send"><code>send</code></a>, but it spends gas from a reservation instead of borrowing
it from the gas limit provided with the incoming message.</div></li><li><div class="item-name"><a class="fn" href="fn.send_from_reservation_for_reply.html" title="fn gstd::msg::send_from_reservation_for_reply">send_from_reservation_for_reply</a></div><div class="desc docblock-short">Same as <a href="fn.send_from_reservation.html" title="fn gstd::msg::send_from_reservation"><code>send_from_reservation</code></a>, but the program
will interrupt until the reply is received.</div></li><li><div class="item-name"><a class="fn" href="fn.send_from_reservation_for_reply_as.html" title="fn gstd::msg::send_from_reservation_for_reply_as">send_from_reservation_for_reply_as</a></div><div class="desc docblock-short">Same as <a href="fn.send_from_reservation.html" title="fn gstd::msg::send_from_reservation"><code>send_from_reservation</code></a>, but the program
will interrupt until the reply is received.</div></li><li><div class="item-name"><a class="fn" href="fn.send_input.html" title="fn gstd::msg::send_input">send_input</a></div><div class="desc docblock-short">Same as <a href="fn.send.html" title="fn gstd::msg::send"><code>send</code></a> but uses the input buffer as a payload source.</div></li><li><div class="item-name"><a class="fn" href="fn.send_input_delayed.html" title="fn gstd::msg::send_input_delayed">send_input_delayed</a></div><div class="desc docblock-short">Same as <a href="fn.send_input.html" title="fn gstd::msg::send_input"><code>send_input</code></a>, but sends the message after the <code>delay</code> expressed in
block count.</div></li><li><div class="item-name"><a class="fn" href="fn.send_input_for_reply.html" title="fn gstd::msg::send_input_for_reply">send_input_for_reply</a></div><div class="desc docblock-short">Same as <a href="fn.send_input.html" title="fn gstd::msg::send_input"><code>send_input</code></a>, but the program
will interrupt until the reply is received.</div></li><li><div class="item-name"><a class="fn" href="fn.send_input_for_reply_as.html" title="fn gstd::msg::send_input_for_reply_as">send_input_for_reply_as</a></div><div class="desc docblock-short">Same as <a href="fn.send_input.html" title="fn gstd::msg::send_input"><code>send_input</code></a>, but the program
will interrupt until the reply is received.</div></li><li><div class="item-name"><a class="fn" href="fn.send_input_with_gas.html" title="fn gstd::msg::send_input_with_gas">send_input_with_gas</a></div><div class="desc docblock-short">Same as <a href="fn.send_input.html" title="fn gstd::msg::send_input"><code>send_input</code></a>, but with an explicit gas limit.</div></li><li><div class="item-name"><a class="fn" href="fn.send_input_with_gas_delayed.html" title="fn gstd::msg::send_input_with_gas_delayed">send_input_with_gas_delayed</a></div><div class="desc docblock-short">Same as <a href="fn.send_input_with_gas.html" title="fn gstd::msg::send_input_with_gas"><code>send_input_with_gas</code></a>, but sends the message after the <code>delay</code>
expressed in block count.</div></li><li><div class="item-name"><a class="fn" href="fn.send_input_with_gas_for_reply.html" title="fn gstd::msg::send_input_with_gas_for_reply">send_input_with_gas_for_reply</a></div><div class="desc docblock-short">Same as <a href="fn.send_input_with_gas.html" title="fn gstd::msg::send_input_with_gas"><code>send_input_with_gas</code></a>, but the program
will interrupt until the reply is received.</div></li><li><div class="item-name"><a class="fn" href="fn.send_input_with_gas_for_reply_as.html" title="fn gstd::msg::send_input_with_gas_for_reply_as">send_input_with_gas_for_reply_as</a></div><div class="desc docblock-short">Same as <a href="fn.send_input_with_gas.html" title="fn gstd::msg::send_input_with_gas"><code>send_input_with_gas</code></a>, but the program
will interrupt until the reply is received.</div></li><li><div class="item-name"><a class="fn" href="fn.send_with_gas.html" title="fn gstd::msg::send_with_gas">send_with_gas</a></div><div class="desc docblock-short">Same as <a href="fn.send.html" title="fn gstd::msg::send"><code>send</code></a>, but with an explicit gas limit.</div></li><li><div class="item-name"><a class="fn" href="fn.send_with_gas_delayed.html" title="fn gstd::msg::send_with_gas_delayed">send_with_gas_delayed</a></div><div class="desc docblock-short">Same as <a href="fn.send_with_gas.html" title="fn gstd::msg::send_with_gas"><code>send_with_gas</code></a>, but sends the message after the <code>delay</code> expressed
in block count.</div></li><li><div class="item-name"><a class="fn" href="fn.send_with_gas_for_reply.html" title="fn gstd::msg::send_with_gas_for_reply">send_with_gas_for_reply</a></div><div class="desc docblock-short">Same as <a href="fn.send_with_gas.html" title="fn gstd::msg::send_with_gas"><code>send_with_gas</code></a>, but the program
will interrupt until the reply is received.</div></li><li><div class="item-name"><a class="fn" href="fn.send_with_gas_for_reply_as.html" title="fn gstd::msg::send_with_gas_for_reply_as">send_with_gas_for_reply_as</a></div><div class="desc docblock-short">Same as <a href="fn.send_with_gas.html" title="fn gstd::msg::send_with_gas"><code>send_with_gas</code></a>, but the program
will interrupt until the reply is received.</div></li><li><div class="item-name"><a class="fn" href="fn.signal_code.html" title="fn gstd::msg::signal_code">signal_code</a></div><div class="desc docblock-short">Get the signal code of the message being processed.</div></li><li><div class="item-name"><a class="fn" href="fn.signal_from.html" title="fn gstd::msg::signal_from">signal_from</a></div><div class="desc docblock-short">Get an identifier of the message which issued a signal.</div></li><li><div class="item-name"><a class="fn" href="fn.size.html" title="fn gstd::msg::size">size</a></div><div class="desc docblock-short">Get the payload size of the message that is being processed.</div></li><li><div class="item-name"><a class="fn" href="fn.source.html" title="fn gstd::msg::source">source</a></div><div class="desc docblock-short">Get the identifier of the message source (256-bit address).</div></li><li><div class="item-name"><a class="fn" href="fn.value.html" title="fn gstd::msg::value">value</a></div><div class="desc docblock-short">Get the value associated with the message that is being processed.</div></li><li><div class="item-name"><a class="fn" href="fn.with_read_on_stack.html" title="fn gstd::msg::with_read_on_stack">with_read_on_stack</a></div><div class="desc docblock-short">Calls function <code>f</code> with read message payload on stack buffer.</div></li></ul></section></div></main></body></html>